**js到底是什么类型语言**

JavaScript 代码需要在机器（node 或者浏览器）上安装一个工具（JS 引擎）才能执行。这是解释型语言需要的。编译型语言程序能够自由地直接运行。

变量提升不是代码修改。在这个过程中没有生成中间代码。变量提升只是 JS 解释器处理事情的方式。

JIT（just-in-time compilation 是唯一一点我们可以对 JavaScript 是否是一个解释型语言提出疑问的理由。但是 JIT 不是完整的编译器，它在执行前进行编译。而且 JIT 只是 Mozilla 和 Google 的开发人员为了提升浏览器性能才引入的。JavaScript 或 TC39 从来没有强制要求使用 JIT。

因此，虽然 JavaScript 执行时像是在编译或者像是一种编译和解释的混合，我仍然认为 JavaScript 是一个解释型语言或者是一个今天很多人说的混合型语言，而不是编译型语言。

**js编译原理**

JS编译分三个步骤，词法分析、语法分析以及代码生成，编译过程涉及三个角色，引擎、编译器和作用域。

编译过程涉及三个角色，引擎、编译器和作用域。

引擎是贯穿整个编译过程的，相当于主干。而编译器，主要是负责词法分析、语法分析与代码生成。作用域主要负责收集与维护标识符集合（应该就是我们声明的变量），并且控制当前代码对标识符的访问权限。先来看看词法分析、语法分析、代码生成的过程。

举个例子： 对于var a = 2;

词法分析： 编译器会把var a = 2;这个字符串拆分成词法单元，也就是var、a、=、2、;，词法生成器判断a是一个独立的词法单元还是其他词法单元的一部分，如果用的是有状态的解析规则，这个过程就是词法分析。

语法解析：将词法单元流（也就是[var,a,=,2,;]）转换成 由元素逐级嵌套的 代表了 程序语法结构的树，也就是抽象语法树（Abstract Syntax Tree），简称AST，这个过程是语法解析。

代码生成： 将AST转换成一组机器指令，用来创建一个叫做a的变量，包括分配内存等，并存储一个值在a中

整个流程： 首先，当**编译器**遇到var a的时候，**编译器**会去询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明

接下来**编译器会为引擎生成运行时所需要的代码**，这些代码被用来处理a=2这个赋值操作。**引擎**会先询问作用域，在当前作用域集是否存在a这个变量，如果是，引擎会直接使用这个变量，如果不是，就继续寻找

编译型和解释型语言最重要的区别是编译语言话很长的时间来准备执行。因为它需要对整个代码进行词法分析、做一些极致的优化等工作。另一方面解释型语言几乎在执行后一瞬间就开始，但是没有任何代码优化。所以每一条语句都是分开转换的，考虑下面这一段代码。 `for(i=0; i&lt;1000; i++){    sum += i; }` 在编译型语言中`sum += i`部分在循环运行时已经编译成了机器码，机器码将直接运行一千次。 但是在解释型语言中，他会在执行时将`sum += i`解释一千次。所以因为对相同的代码进行一千次转换会造成非常大的性能损耗。 这就是Google和Mozilla的开发人员将**JIT**加入JavaScript的原因。

下面是JavaScript处理声明语句的过程：

- 一旦 V8 引擎进入一个执行具体代码的执行上下文（函数），它就对代码进行词法分析或者分词。这意味着代码将被分割成像foo = 10这样的原子符号（atomic token）。
- 在对当前的整个作用域分析完成后，引擎将 token 解析翻译成一个AST（抽象语法树）。
- 引擎每次遇到声明语句，就会把声明传到作用域（scope）中创建一个绑定。每次声明都会为变量分配内存。只是分配内存，并不会修改源代码将变量声明语句提升。正如你所知道的，在JS中分配内存意味着将变量默认设为undefined。
- 在这之后，引擎每一次遇到赋值或者取值，都会通过作用域（scope）查找绑定。如果在当前作用域中没有查找到就接着向上级作用域查找直到找到为止。
- 接着引擎生成 CPU 可以执行的机器码。
- 最后， 代码执行完毕。

**AST**

recast、[抽象语法树](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#node_objects)

**事件循环机制**



**宏任务、微任务**



**node是单线程，为什么能处理高并发**



**node事件循环机制**



**跨域的解决方式，cors、jsonp**



**缓存机制，304、强缓存**



**web安全、xss，csrf**



**node错误处理**



**koa中间件机制、解决了什么问题、怎么实现**



**如何理解前后端分离**



**react ssr 实现难点、如何区分服务端环境还是客户端环境**



**多实例如何保存登录状态，也就是session如何存储**



**快应用和微信小程序底层机制区别**



**常用设计模式有哪些，具体应用场景是什么**



**数据库死锁如何解决**



**介绍消息队列以及应用**



**说说对MVVM的理解**

MVVM是Model-View-ViewModel的